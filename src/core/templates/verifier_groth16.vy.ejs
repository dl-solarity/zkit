# pragma version ~=0.4.0

# AUTOGENERATED FILE BY HARDHAT-ZKIT. DO NOT EDIT.

# @dev base field size
BASE_FIELD_SIZE: constant(uint256) = 21888242871839275222246405745257275088696311157297823662689037894645226208583

# @dev verification key data
ALPHA_X: constant(uint256) = <%=vk_alpha_1[0]%>
ALPHA_Y: constant(uint256) = <%=vk_alpha_1[1]%>
BETA_X1: constant(uint256) = <%=vk_beta_2[0][1]%>
BETA_X2: constant(uint256) = <%=vk_beta_2[0][0]%>
BETA_Y1: constant(uint256) = <%=vk_beta_2[1][1]%>
BETA_Y2: constant(uint256) = <%=vk_beta_2[1][0]%>
GAMMA_X1: constant(uint256) = <%=vk_gamma_2[0][1]%>
GAMMA_X2: constant(uint256) = <%=vk_gamma_2[0][0]%>
GAMMA_Y1: constant(uint256) = <%=vk_gamma_2[1][1]%>
GAMMA_Y2: constant(uint256) = <%=vk_gamma_2[1][0]%>
DELTA_X1: constant(uint256) = <%=vk_delta_2[0][1]%>
DELTA_X2: constant(uint256) = <%=vk_delta_2[0][0]%>
DELTA_Y1: constant(uint256) = <%=vk_delta_2[1][1]%>
DELTA_Y2: constant(uint256) = <%=vk_delta_2[1][0] -%>


IC: constant(uint256[<%=IC.length%>][2]) = [
<% IC.forEach(function(innerArray, index) { %>  [
    <%= innerArray[0] %>,
    <%= innerArray[1] %>
  ]<%= index < IC.length - 1 ? ',' : '' %>
<% }); %>]

EC_ADD_PRECOMPILED_ADDRESS: constant(address) = 0x0000000000000000000000000000000000000006
EC_MUL_PRECOMPILED_ADDRESS: constant(address) = 0x0000000000000000000000000000000000000007
EC_PAIRING_PRECOMPILED_ADDRESS: constant(address) = 0x0000000000000000000000000000000000000008


@view
@external
def verifyProof(pointA: uint256[2], pointB: uint256[2][2], pointC: uint256[2], publicSignals: uint256[<%=IC.length-1%>]) -> bool:
    # @dev check that all public signals are in F
    for signal: uint256 in publicSignals:
        if signal >= BASE_FIELD_SIZE:
            return False

    return self._checkPairing(pointA, pointB, pointC, publicSignals)


@view
@internal
def _g1MulAdd(pR: uint256[2], pP: uint256[2], s: uint256) -> (bool, uint256[2]):
    success: bool = True
    response: Bytes[64] = b""
    success, response = raw_call(
        EC_MUL_PRECOMPILED_ADDRESS,
        abi_encode(pP, s),
        max_outsize=64,
        is_static_call=True,
        revert_on_failure=False
    )

    if not success:
        return (False, [0, 0])

    x: uint256 = convert(slice(response, 0, 32), uint256)
    y: uint256 = convert(slice(response, 32, 32), uint256)
    pS: uint256[2] = [x, y]

    success, response = raw_call(
        EC_ADD_PRECOMPILED_ADDRESS,
        abi_encode(pR, pS),
        max_outsize=64,
        is_static_call=True,
        revert_on_failure=False
    )

    if not success:
        return (False, [0, 0])

    x = convert(slice(response, 0, 32), uint256)
    y = convert(slice(response, 32, 32), uint256)

    return (True, [x, y])


@view
@internal
def _checkPairing(pA: uint256[2], pB: uint256[2][2], pC: uint256[2], pubSignals: uint256[<%=IC.length-1%>]) -> bool:
    success: bool = True
    mulAddResult: uint256[2] = IC[0]

    # @dev compute the linear combination of public signals
    for i: uint256 in range(1, <%=IC.length%>):
        success, mulAddResult = self._g1MulAdd(mulAddResult, IC[i], pubSignals[i - 1])
        if not success:
            return False

    response: Bytes[32] = b""
    success, response = raw_call(
        EC_PAIRING_PRECOMPILED_ADDRESS,
        abi_encode(
            pA[0], (BASE_FIELD_SIZE - pA[1]) % BASE_FIELD_SIZE,
            pB,
            ALPHA_X, ALPHA_Y,
            BETA_X1, BETA_X2, BETA_Y1, BETA_Y2,
            mulAddResult,
            GAMMA_X1, GAMMA_X2, GAMMA_Y1, GAMMA_Y2,
            pC,
            DELTA_X1, DELTA_X2, DELTA_Y1, DELTA_Y2
        ),
        max_outsize=32,
        is_static_call=True,
        revert_on_failure=False
    )

    if not success:
        return False

    return convert(response, bool)
